#! /bin/ruby

require 'json'
require 'net/http'
require 'optparse'
require 'uri'

# Provide a CLI for a Coronavirus API; I'll use it to make cool statusbar
# widgets.

# API response format:
# Array of hashes of countries and states, each with the following fields:
# "country",
# "province",
# "countryCode",
# "confirmed",
# "recovered",
# "deaths",
# "confirmedByDay",
# "recoveredByDay",
# "deathsByDay",
# "lastUpdated",
# "active",
# "mortalityPer",
# "recoveredPer"

OptionParser.new do |options|
  @options = {}
  options.banner = 'Coronavirus Tracker'

  options.on '-h', '--help', 'Print Help' do
    puts options
    puts "Fields may be 'confirmed', 'recovered', 'deaths', or 'active'."
    exit
  end

  # - force cache update
  @options[:use_cache] = true
  options.on '-U', '--update', 'Force Download' do
    @options[:use_cache] = false
  end

  # # - location
  # options.on '-l', '--location [LOCATION]', 'Which location?' do |l|
  #   @options[:location] = l
  # end
  #
  # - which data to return
  @options[:fields] = %w[active deaths]
  options.on '-f', '--fields', 'Which numbers' do |f|
    options[:fields] = f.split(' ')
  end

  @options[:emojis] = false
  options.on '-e', '--emojis', 'Replace words with emojis' do
    @options[:emojis] = true
  end
end.parse!(ARGV)

@options[:locations] = ARGV
@options[:locations] << 'World' if @options[:locations].empty?

def output
  @options[:locations].map { |l| location_output(l) }
                      .join(' | ')
end

def location_output(location)
  location_data = find_by_location(location)
  sum_data = sum_data_string(sum(location_data, @options[:fields]))

  "#{location}: #{sum_data}"
end

# Input: hash
# Output: string
def sum_data_string(input_data)
  pairs = []
  input_data.each_pair do |key, val|
    # Shamelessly stolen from SO
    formatted_val = val.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
    pairs << "#{formatted_val} #{formatted_key(key)}"
  end

  pairs.join(', ')
end

def emojis
  {
    'active' => 'ðŸ˜·',
    'deaths' => 'ðŸ’€',
    'confirmed' => 'ðŸ“ˆ',
    'recovered' => 'âœ…'
  }
end

def formatted_key(key)
  @options[:emojis] ? emojis[key] : key
end

def data
  @data ||= JSON.parse(use_cache? ? read_cache : fetch_data)
end

def use_cache?
  @options[:use_cache] &&
    cache_exists? &&
    File.mtime(cache_name) > Time.now - (6 * 3600)
end

def cache_exists?
  @cache_exists ||= File.exist?(cache_name)
end

def cache_name
  "#{Dir.home}/.cache/coronavirus_data.json"
end

def response
  @response ||= Net::HTTP.get_response(
    URI.parse('https://corona-stats.online?format=json')
  )
end

def fetch_data
  # raise response.message unless response.is_a? Net::HTTPSuccess
  if response.is_a? Net::HTTPSuccess
    write_cache
    response.body
  elsif cache_exists?
    warn 'Could not download new data. Using old cache. ' + response.message
    read_cache
  else
    raise response.message
  end
end

def write_cache
  cache = File.new(cache_name, 'w')

  cache << response.body

  cache.flush
  cache.close
end

def read_cache
  File.read(cache_name)
end

# Returns an array of locations which match the given query.
def find_by_location(query)
  data.select do |d|
    [d['country'], d['countryCode'], d['province']]
      .compact # Not all locations have a province.
      .map(&:downcase)
      .include?(query.downcase)
  end
end

# Accepts an array of hashes (data), and an array of strings (fields), returns a
# hash of sums for the given fields.
def sum(input_data, fields)
  summed = {}
  fields.each do |field|
    summed[field] = input_data.map { |d| d[field] }.sum
  end

  summed
end

$stdout.write output
